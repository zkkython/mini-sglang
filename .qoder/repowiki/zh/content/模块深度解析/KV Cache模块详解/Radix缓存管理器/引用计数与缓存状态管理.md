# 引用计数与缓存状态管理

<cite>
**本文档中引用的文件**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py)
- [base.py](file://python/minisgl/kvcache/base.py)
- [cache.py](file://python/minisgl/scheduler/cache.py)
- [prefill.py](file://python/minisgl/scheduler/prefill.py)
- [scheduler.py](file://python/minisgl/scheduler/scheduler.py)
- [core.py](file://python/minisgl/core.py)
</cite>

## 目录
1. [引言](#引言)
2. [核心组件](#核心组件)
3. [引用计数机制](#引用计数机制)
4. [缓存状态管理](#缓存状态管理)
5. [前缀匹配与插入](#前缀匹配与插入)
6. [缓存驱逐机制](#缓存驱逐机制)
7. [系统集成与调用流程](#系统集成与调用流程)
8. [结论](#结论)

## 引言
本文档全面解析基于引用计数的缓存生命周期管理机制。重点分析`lock_handle`方法如何通过递归遍历父节点来增减引用计数（ref_count），并同步更新`evictable_size`和`protected_size`这两个关键状态变量。解释当引用计数从1减至0时，节点及其子树变为可驱逐状态，`evictable_size`相应增加；反之，当引用计数从0增至1时，节点被保护，`protected_size`增加。阐明`match_prefix`和`insert_prefix`如何通过`_walk`间接影响节点的访问时间戳和潜在的引用状态。说明这种设计如何精确跟踪哪些缓存块正在被使用（protected）而哪些可以被安全回收（evictable）。

## 核心组件

**本节来源**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L13-L221)
- [base.py](file://python/minisgl/kvcache/base.py#L50-L135)

## 引用计数机制

```mermaid
classDiagram
class RadixTreeNode {
+children : Dict[int, RadixTreeNode]
+_parent : RadixTreeNode | None
+ref_count : int
+uuid : int
+timestamp : int
+_key : torch.Tensor
+_value : torch.Tensor
+_length : int
+set_key_value(key, value) void
+set_parent(parent) void
+length() int
+parent() RadixTreeNode
+value() torch.Tensor
+is_root() bool
+is_leaf() bool
+get_match_len(input_ids) int
+_split_at(pos) RadixTreeNode
}
class RadixCacheManager {
+device : torch.device
+empty_tensor : torch.Tensor
+root_node : RadixTreeNode
+evictable_size : int
+protected_size : int
+lock_handle(handle, unlock) void
+match_prefix(input_ids) Tuple[RadixCacheHandle, torch.Tensor]
+insert_prefix(input_ids, indices) int
+_walk(input_ids) Tuple[RadixTreeNode, int]
+evict(size) torch.Tensor
+_collect_leave_nodes_for_evict() List[RadixTreeNode]
+reset() None
+size_info() SizeInfo
+check_integrity() None
}
class RadixCacheHandle {
+node : RadixTreeNode
+cached_len : int
}
RadixCacheManager --> RadixTreeNode : "管理"
RadixCacheHandle --> RadixTreeNode : "引用"
RadixCacheManager --> RadixCacheHandle : "创建"
```

**图示来源**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L13-L221)

**本节来源**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L97-L115)

## 缓存状态管理

```mermaid
flowchart TD
Start([开始]) --> CheckUnlock["检查是否为解锁操作"]
CheckUnlock --> |是| TraverseUpUnlock["向上遍历父节点"]
CheckUnlock --> |否| TraverseUpLock["向上遍历父节点"]
TraverseUpUnlock --> CheckRootUnlock["是否为根节点？"]
CheckRootUnlock --> |否| DecRefCount["引用计数减1"]
DecRefCount --> CheckRefCountZero["引用计数是否为0？"]
CheckRefCountZero --> |是| UpdateSizesUnlock["evictable_size += 长度<br/>protected_size -= 长度"]
CheckRefCountZero --> |否| ContinueUnlock["继续向上遍历"]
UpdateSizesUnlock --> ContinueUnlock
ContinueUnlock --> CheckRootUnlock
CheckRootUnlock --> |是| EndUnlock([结束])
TraverseUpLock --> CheckRootLock["是否为根节点？"]
CheckRootLock --> |否| CheckRefCountZeroLock["引用计数是否为0？"]
CheckRefCountZeroLock --> |是| UpdateSizesLock["evictable_size -= 长度<br/>protected_size += 长度"]
CheckRefCountZeroLock --> |否| ContinueLock["继续向上遍历"]
UpdateSizesLock --> IncRefCount["引用计数加1"]
IncRefCount --> ContinueLock
ContinueLock --> CheckRootLock
CheckRootLock --> |是| EndLock([结束])
```

**图示来源**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L97-L115)

**本节来源**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L94-L95)
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L105-L108)
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L111-L114)

## 前缀匹配与插入

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Manager as "RadixCacheManager"
participant Node as "RadixTreeNode"
Client->>Manager : match_prefix(input_ids)
Manager->>Manager : _walk(input_ids)
loop 遍历输入ID
Manager->>Node : 检查子节点是否存在
alt 子节点存在
Manager->>Node : 获取匹配长度
Manager->>Node : 更新节点时间戳
Manager->>Manager : 累加匹配长度
else 子节点不存在
Manager-->>Manager : 返回当前节点和匹配长度
end
end
Manager->>Manager : 收集匹配的value值
Manager-->>Client : 返回Handle和匹配的indices
Client->>Manager : insert_prefix(input_ids, indices)
Manager->>Manager : _walk(input_ids)
Manager->>Manager : 检查是否需要插入新节点
alt 需要插入
Manager->>Node : 创建新节点
Manager->>Node : 设置键值对
Manager->>Node : 设置父节点
Manager->>Manager : evictable_size += 新节点长度
end
Manager-->>Client : 返回已缓存的前缀长度
```

**图示来源**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L116-L136)
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L138-L163)

**本节来源**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L116-L136)
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L138-L163)

## 缓存驱逐机制

```mermaid
flowchart TD
Start([开始驱逐]) --> CheckSize["检查请求大小是否为0"]
CheckSize --> |是| ReturnEmpty["返回空张量"]
CheckSize --> |否| ValidateSize["验证可驱逐大小"]
ValidateSize --> CollectNodes["收集可驱逐的叶子节点"]
CollectNodes --> Heapify["构建最小堆"]
Heapify --> CheckEvicted["已驱逐大小 < 请求大小？"]
CheckEvicted --> |是| PopNode["从堆中弹出最旧节点"]
PopNode --> ValidateNode["验证节点状态"]
ValidateNode --> UpdateCounters["更新驱逐计数器"]
UpdateCounters --> RemoveFromParent["从父节点删除"]
RemoveFromParent --> CheckParent["父节点是否变为叶子节点且可驱逐？"]
CheckParent --> |是| PushParent["将父节点加入堆"]
CheckParent --> |否| ContinueLoop["继续循环"]
PushParent --> ContinueLoop
ContinueLoop --> CheckEvicted
CheckEvicted --> |否| ConcatResult["连接驱逐的indices"]
ConcatResult --> ReturnResult["返回驱逐结果"]
```

**图示来源**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L165-L192)
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L194-L207)

**本节来源**  
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L165-L192)
- [radix_manager.py](file://python/minisgl/kvcache/radix_manager.py#L194-L207)

## 系统集成与调用流程

```mermaid
sequenceDiagram
participant Scheduler as "Scheduler"
participant CacheMgr as "CacheManager"
participant RadixMgr as "RadixCacheManager"
Scheduler->>CacheMgr : match_req(req)
CacheMgr->>RadixMgr : match_prefix(input_ids)
RadixMgr-->>CacheMgr : 返回Handle和indices
CacheMgr-->>Scheduler : 返回匹配结果
Scheduler->>CacheMgr : lock(handle)
CacheMgr->>RadixMgr : lock_handle(handle, unlock=False)
RadixMgr-->>CacheMgr : 更新引用计数和状态
CacheMgr-->>Scheduler : 锁定完成
Scheduler->>CacheMgr : allocate(needed_len)
CacheMgr->>RadixMgr : evict(size)
RadixMgr-->>CacheMgr : 返回驱逐的indices
CacheMgr-->>Scheduler : 返回分配的indices
Scheduler->>CacheMgr : free_and_cache_finished_req()
CacheMgr->>RadixMgr : insert_prefix(input_ids, indices)
RadixMgr-->>CacheMgr : 返回已缓存长度
CacheMgr->>RadixMgr : unlock(old_handle)
RadixMgr-->>CacheMgr : 更新引用计数和状态
CacheMgr-->>Scheduler : 释放和缓存完成
```

**图示来源**  
- [cache.py](file://python/minisgl/scheduler/cache.py#L24-L62)
- [prefill.py](file://python/minisgl/scheduler/prefill.py#L38-L61)
- [scheduler.py](file://python/minisgl/scheduler/scheduler.py#L145-L149)

**本节来源**  
- [cache.py](file://python/minisgl/scheduler/cache.py#L24-L62)
- [prefill.py](file://python/minisgl/scheduler/prefill.py#L38-L61)
- [scheduler.py](file://python/minisgl/scheduler/scheduler.py#L145-L149)

## 结论
本文档详细解析了基于引用计数的缓存生命周期管理机制。通过`RadixCacheManager`中的`lock_handle`方法，系统能够精确地管理缓存块的生命周期。当引用计数从0增加到1时，节点被保护，`protected_size`增加；当引用计数从1减少到0时，节点变为可驱逐状态，`evictable_size`增加。`match_prefix`和`insert_prefix`方法通过`_walk`操作不仅实现了前缀匹配和插入功能，还间接影响了节点的访问时间戳和引用状态。这种设计使得系统能够精确跟踪哪些缓存块正在被使用而哪些可以被安全回收，从而实现了高效的内存管理和缓存驱逐策略。